<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Bad Apple ASCII Player</title>
    <style>
        body { background: black; color: white; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; margin: 0; font-family: monospace; }
        #ascii-output { white-space: pre; line-height: 1.0; letter-spacing: 0; font-weight: bold; text-align: center; }
        #controls { margin-top: 20px; background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px; }
        input[type="file"] { margin-bottom: 10px; }
        button { padding: 10px 20px; cursor: pointer; background: #007bff; color: white; border: none; border-radius: 5px; font-weight: bold; }
        video { display: none; }
    </style>
</head>
<body>
    <div id="ascii-output">영상을 선택하거나 재생 버튼을 눌러주세요.</div>

    <div id="controls">
        <input type="file" id="file-input" accept="video/*"><br>
        <button id="btn">PLAY / PAUSE</button>
    </div>

    <video id="video" loop preload="auto" crossorigin="anonymous"></video>
    <canvas id="canvas" style="display:none;"></canvas>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const output = document.getElementById('ascii-output');
        const btn = document.getElementById('btn');
        const fileInput = document.getElementById('file-input');

        const asciiChars = " .-:=+*#%@"; 
        const charRatio = 0.55; 

        // 파일 선택 시 비디오 연결
        fileInput.onchange = (e) => {
            const file = e.target.files[0];
            if (file) {
                video.src = URL.createObjectURL(file);
                output.textContent = "영상이 로드되었습니다. 재생을 누르세요!";
            }
        };

        function render() {
            if (video.paused || video.ended) return;

            // 정수값 보장 (Math.floor 추가하여 'long' 타입 에러 방지)
            const w = 120;
            const h = Math.floor(w / (video.videoWidth / video.videoHeight) * charRatio);
            
            if (isNaN(h) || h <= 0) { // 비디오 정보가 아직 없을 때 예외처리
                requestAnimationFrame(render);
                return;
            }

            canvas.width = w;
            canvas.height = h;

            ctx.drawImage(video, 0, 0, w, h);
            const data = ctx.getImageData(0, 0, w, h).data;
            let art = "";

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const i = (y * w + x) * 4;
                    const gray = (data[i] + data[i+1] + data[i+2]) / 3;
                    const charIdx = Math.floor((gray / 255) * (asciiChars.length - 1));
                    art += asciiChars[charIdx];
                }
                art += "\n";
            }

            output.textContent = art;
            output.style.fontSize = (window.innerWidth / w * 1.6) + "px";

            requestAnimationFrame(render);
        }

        btn.onclick = async () => {
            try {
                if (video.paused) {
                    await video.play(); // play()가 완료될 때까지 대기하여 AbortError 방지
                    render();
                } else {
                    video.pause();
                }
            } catch (err) {
                console.error("재생 중 오류:", err);
            }
        };
    </script>
</body>
</html>
